{"version":3,"file":"static/js/789.fc4f0a97.chunk.js","mappings":"qNAGe,SAASA,IACtB,IAAMC,EAAM,CAAC,EAAG,EAAG,QAAS,GAAI,EAAG,EAAG,GAAI,QAAS,GA+BnD,SAASC,EAAQC,GAAwB,IAAXC,EAAIC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,EACnC,OAAO,IAAIG,SAAQ,SAACC,EAASC,GAC3BC,YAAW,WACTC,QAAQC,IAAI,iCAAUV,GAClBW,KAAKC,SAAW,GAClBN,EAAQ,gBAERC,EAAO,gBAEX,GAAU,IAAPN,EACL,GACF,EC9CF,SACEY,EACAC,EACAC,GAEA,IAAMC,EAAgBH,EAAYI,QAE5BC,EAAgBP,KAAKQ,IAAIL,EAAQD,EAAYV,QAC/CiB,EAAkB,EAWhBC,EAAU,WACd,IAAMC,EAAON,EAASO,QACtBD,GAAQE,EAAOF,EACjB,EAGME,EAAM,eAAAC,GAAAC,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,KAAAC,MAAG,SAAAC,EAAOP,GAAe,OAAAK,EAAAA,EAAAA,KAAAG,MAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,OAEf,OAFeF,EAAAC,KAAA,EAEjCZ,IAAkBW,EAAAE,KAAA,EACZX,IAAO,KAAD,EAAAS,EAAAE,KAAA,gBAAAF,EAAAC,KAAA,EAAAD,EAAAG,GAAAH,EAAA,SAEZtB,QAAQC,IAAI,wCACZD,QAAQC,IAAGqB,EAAAG,IACXzB,QAAQC,IAAI,wCAAwC,QAK3C,OAL2CqB,EAAAC,KAAA,GAGpDZ,IAEAe,IAASJ,EAAAK,OAAA,6BAAAL,EAAAM,OAAA,GAAAR,EAAA,wBAEZ,gBAdWS,GAAA,OAAAb,EAAAc,MAAA,KAAArC,UAAA,KAgBNiC,EAAS,WAETf,EAAkBN,GAAUE,EAASb,OAAS,EAEhDkB,IAE4B,GAAnBL,EAASb,QAAkC,GAAnBiB,GAGjCL,GAAYA,GAEhB,GA1CsB,WAGpB,IAFA,IAAIyB,EAAI,EAEDA,EAAItB,GACTsB,IACAnB,GAEJ,CAuCAoB,EACF,CDzCEC,CACE,CACE,kBAAM3C,EAAQ,IAAI,EAElB,kBAAMA,EAAQ,IAAI,EAElB,kBAAMA,EAAQ,IAAI,EAElB,kBAAMA,EAAQ,IAAI,GAGpB,GAEA,SAAC4C,GACClC,QAAQC,IAAIiC,EACd,IAiBFlC,QAAQC,IA3CO,SAACZ,GACd,OAAA8C,EAAAA,EAAAA,GAAW,IAAIC,IAAI/C,GACrB,CAyCYgD,CAAOhD,IACnBW,QAAQC,IAzCQ,SAACZ,GACf,OAAOA,EAAIiD,QAAO,SAACC,EAAWnD,EAAYoD,GACxC,OAAOA,EAAMC,QAAQF,KAAUnD,CACjC,GACF,CAqCYsD,CAAQrD,IAEpB,IAAMsD,EAAO,CACX,CAAEC,GAAI,EAAGC,KAAM,gBAAOC,SAAU,GAChC,CAAEF,GAAI,EAAGC,KAAM,gBAAOC,SAAU,GAChC,CAAEF,GAAI,EAAGC,KAAM,gBAAOC,SAAU,GAChC,CAAEF,GAAI,EAAGC,KAAM,gBAAOC,SAAU,GAChC,CAAEF,GAAI,EAAGC,KAAM,gBAAOC,SAAU,GAChC,CAAEF,GAAI,EAAGC,KAAM,gBAAOC,SAAU,IA2FlC,OAJA9C,QAAQC,IAAI,wCACZD,QAAQC,IAjDR,SAAiBZ,GACf,IAAM0D,EAAW,CAAC,EACZC,EAAc,GAepB,OAZA3D,EAAI4D,SAAQ,SAACV,GACXQ,EAAIR,EAAKK,KAAGM,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GAAQX,GAAI,IAAEY,SAAU,IACtC,IAGA9D,EAAI4D,SAAQ,SAACV,GACW,IAAlBA,EAAKO,SACPC,EAAIR,EAAKO,UAAUK,SAASC,KAAKL,EAAIR,EAAKK,KAE1CI,EAAKI,KAAKL,EAAIR,EAAKK,IAEvB,IACOI,CACT,CA+BYK,CAAQV,IACpB3C,QAAQC,IA9BR,SAAkBZ,GAChB,IAAMiE,EAAa,IAAIC,IACjBC,EAAc,GAuBpB,OApBAnE,EAAI4D,SAAQ,SAACQ,GACXA,EAAKN,SAAW,GAChBG,EAAWI,IAAID,EAAKb,GAAIa,EAC1B,IACAzD,QAAQC,IAAI,wCACZD,QAAQC,IAAIqD,GACZtD,QAAQC,IAAI,wCAEZZ,EAAI4D,SAAQ,SAACQ,GACX,IAAMX,EAAWW,EAAKX,SAChBa,EAAaL,EAAWM,IAAId,GAClC9C,QAAQC,IAAI,wCACZD,QAAQC,IAAI0D,GACZ3D,QAAQC,IAAI,wCACR0D,EACFA,EAAWR,SAASC,KAAKK,GAEzBD,EAAOJ,KAAKK,EAEhB,IACOD,CACT,CAIYK,CAASlB,IACrB3C,QAAQC,IAAI,yCACL6D,EAAAA,EAAAA,KAAA,OAAAX,SAAK,cACd,C","sources":["comment/gmme/index.tsx","request/index.ts"],"sourcesContent":["import React from \"react\";\r\nimport { sendRequest } from \"../../request\";\r\n\r\nexport default function index() {\r\n  const arr = [1, 2, \"hello\", 34, 2, 5, 34, \"hello\", 2];\r\n  const unique = (arr: Iterable<unknown> | null | undefined) => {\r\n    return [...new Set(arr)];\r\n  };\r\n  const unique1 = (arr: any) => {\r\n    return arr.filter((item: any, index: any, array: string | any[]) => {\r\n      return array.indexOf(item) === index;\r\n    });\r\n  };\r\n\r\n  // 设计一个函数，可以限制请求的并发，同时请求结束之后，调用callback函数\r\n  // sendRequest(requestList:,limits,callback):void\r\n  sendRequest(\r\n    [\r\n      () => request(\"1\"),\r\n\r\n      () => request(\"2\"),\r\n\r\n      () => request(\"3\"),\r\n\r\n      () => request(\"4\"),\r\n    ],\r\n\r\n    3, //并发数\r\n\r\n    (res: any) => {\r\n      console.log(res);\r\n    }\r\n  );\r\n\r\n  // 其中request 可以是：\r\n  function request(url: string, time = 1) {\r\n    return new Promise((resolve, reject) => {\r\n      setTimeout(() => {\r\n        console.log(\"请求结束：\" + url);\r\n        if (Math.random() > 0.5) {\r\n          resolve(\"成功\");\r\n        } else {\r\n          reject(\"错误;\");\r\n        }\r\n      }, time * 1e3);\r\n    });\r\n  }\r\n\r\n  console.log(unique(arr));\r\n  console.log(unique1(arr));\r\n\r\n  const arr1 = [\r\n    { id: 1, name: \"部门A\", parentId: 0 },\r\n    { id: 2, name: \"部门B\", parentId: 1 },\r\n    { id: 3, name: \"部门C\", parentId: 1 },\r\n    { id: 4, name: \"部门D\", parentId: 2 },\r\n    { id: 5, name: \"部门E\", parentId: 2 },\r\n    { id: 6, name: \"部门F\", parentId: 3 },\r\n  ];\r\n//   [\r\n//     {\r\n//         id: 1,\r\n//         name: '部门A',\r\n//         children: [\r\n//           {\r\n//               id: 2,\r\n//               name: '部门B',\r\n//               children: [\r\n//                   {\r\n//                       id: 4,\r\n//                       name: '部门D',\r\n//                       children: []\r\n//                   },\r\n//                   {\r\n//                       id: 5,\r\n//                       name: '部门E',\r\n//                       children: []\r\n//                   }\r\n//               ]\r\n//           },\r\n//           {\r\n//               id: 3,\r\n//               name: '部门C',\r\n//               children: [\r\n//                 \t{\r\n//                       id: 6,\r\n//                       name: '部门F',\r\n//                       children\r\n//                   }\r\n//               ]\r\n//           }\r\n//         ]\r\n//     }\r\n// ]\r\n\r\n\r\n  function convert(arr: any[]) {\r\n    const map: any = {};\r\n    const tree: any[] = [];\r\n\r\n    // 将每个节点以 id 为键存储到 map 对象中\r\n    arr.forEach((item) => {\r\n      map[item.id] = { ...item, children: [] };\r\n    });\r\n\r\n    // 遍历数组，将每个节点添加到其父节点的 children 数组中\r\n    arr.forEach((item) => {\r\n      if (item.parentId !== 0) {\r\n        map[item.parentId].children.push(map[item.id]);\r\n      } else {\r\n        tree.push(map[item.id]);\r\n      }\r\n    });\r\n    return tree;\r\n  }\r\n\r\n  function convert1(arr: any[]) {\r\n    const nodeParent = new Map();\r\n    const result: any = [];\r\n\r\n    // 构建映射关系\r\n    arr.forEach((node: { children: never[]; id: any }) => {\r\n      node.children = [];\r\n      nodeParent.set(node.id, node);\r\n    });\r\n    console.log('====================================');\r\n    console.log(nodeParent);\r\n    console.log('====================================');\r\n    // 构建树形结构\r\n    arr.forEach((node) => {\r\n      const parentId = node.parentId;\r\n      const parentNode = nodeParent.get(parentId);\r\n      console.log('====================================');\r\n      console.log(parentNode);\r\n      console.log('====================================');\r\n      if (parentNode) {\r\n        parentNode.children.push(node);\r\n      } else {\r\n        result.push(node);\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n\r\n  console.log(\"====================================\");\r\n  console.log(convert(arr1));\r\n  console.log(convert1(arr1));\r\n  console.log(\"====================================\");\r\n  return <div>1111111111</div>;\r\n}\r\n","function sendRequest(\r\n  requestList: string | any[],\r\n  limits: number,\r\n  callback: any\r\n) {\r\n  const promises: any = requestList.slice(); // 取得请求list（浅拷贝一份）\r\n  // 得到开始时，能执行的并发数\r\n  const concurrentNum = Math.min(limits, requestList.length);\r\n  let concurrentCount = 0; // 当前并发数\r\n  // 第一次先跑起可以并发的任务\r\n  const runTaskNeeded = () => {\r\n    let i = 0;\r\n    // 启动当前能执行的任务\r\n    while (i < concurrentNum) {\r\n      i++;\r\n      runTask();\r\n    }\r\n  };\r\n  // 取出任务并且执行任务\r\n  const runTask = () => {\r\n    const task = promises.shift();\r\n    task && runner(task);\r\n  };\r\n  // 执行器\r\n  // 执行任务，同时更新当前并发数\r\n  const runner = async (task: () => any) => {\r\n    try {\r\n      concurrentCount++;\r\n      await task();\r\n    } catch (error) {\r\n      console.log(\"====================================\");\r\n      console.log(error);\r\n      console.log(\"====================================\");\r\n    } finally {\r\n      // 并发数--\r\n      concurrentCount--;\r\n      // 捞起下一个任务\r\n      picker();\r\n    }\r\n  };\r\n  // 捞起下一个任务\r\n  const picker = () => {\r\n    // 任务队列里还有任务并且此时还有剩余并发数的时候 执行\r\n    if (concurrentCount < limits && promises.length > 0) {\r\n      // 继续执行任务\r\n      runTask();\r\n      // 队列为空的时候，并且请求池清空了，就可以执行最后的回调函数了\r\n    } else if (promises.length == 0 && concurrentCount == 0) {\r\n      // 执行结束\r\n\r\n      callback && callback();\r\n    }\r\n  };\r\n\r\n  // 入口执行\r\n\r\n  runTaskNeeded();\r\n}\r\nexport { sendRequest };\r\n"],"names":["index","arr","request","url","time","arguments","length","undefined","Promise","resolve","reject","setTimeout","console","log","Math","random","requestList","limits","callback","promises","slice","concurrentNum","min","concurrentCount","runTask","task","shift","runner","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_context","prev","next","t0","picker","finish","stop","_x","apply","i","runTaskNeeded","sendRequest","res","_toConsumableArray","Set","unique","filter","item","array","indexOf","unique1","arr1","id","name","parentId","map","tree","forEach","_objectSpread","children","push","convert","nodeParent","Map","result","node","set","parentNode","get","convert1","_jsx"],"sourceRoot":""}